import {
  this.error {Argument-Missing, Key-Missing},
  this.parser {Parser, parser},
}

define optional<a>(p: parser(a)): parser(?a) {
  Parser of {
    reader = {
      function (xs: list(text)) {
        let Parser of {reader} = p in
        let Pair(mv, ys) = reader(xs) in
        match mv {
        | Error(Key-Missing(_)) =>
          Pair(OK(none), ys)
        | Error(Argument-Missing(_)) =>
          Pair(OK(none), ys)
        | Error(e) =>
          Pair(Error(e), ys)
        | OK(v) =>
          Pair(OK(OK(v)), ys)
        }
      }
    },
  }
}

inline many<a>(!p: parser(a)): parser(list(a)) {
  Parser of {
    reader = {
      define loop(xs: list(text)) {
        let Parser of {reader} = !p in
        let Pair(mv, ys) = reader(xs) in
        match mv {
        | Error(_) =>
          Pair(OK([]), ys)
        | OK(v) =>
          let Pair(vs-or-error, rest') = loop(ys) in
          match vs-or-error {
          | Error(e) =>
            Pair(Error(e), rest')
          | OK(vs) =>
            Pair(OK(Cons(v, vs)), rest')
          }
        }
      }
    },
  }
}

define choice<a>(ps: list(parser(a)), fallback: parser(a)): parser(a) {
  match ps {
  | Nil =>
    fallback
  | Cons(p, rest) =>
    Parser of {
      reader = {
        function (xs: list(text)) {
          let Parser of {reader} = p in
          let Pair(mv, ys) = reader(xs) in
          match mv {
          | OK(v) =>
            Pair(OK(v), ys)
          | Error(_) =>
            let Parser of {reader} = choice(rest, fallback) in
            reader(ys)
          }
        }
      },
    }
  }
}
