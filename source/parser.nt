import {
  core.functor {Functor, functor},
  core.list {drop, length},
  core.system {get-argv},
  this.error {
    Remaining-Arguments,
    error,
  },
}

data parser(a) {
| Parser(
    reader: (list(text)) -> pair(except(error, a), list(text)),
  )
}

define for-each<a, b>(mx: parser(a), f: (a) -> b): parser(b) {
  Parser(function (xs) {
    let Parser of {reader = g} = mx in
    let Pair(mv, ys) = g(xs) in
    match mv {
    | Error(e) =>
      Pair(Error(e), ys)
    | OK(v) =>
      Pair(OK(f(v)), ys)
    }
  })
}

inline as-functor: functor(parser) {
  Functor of {for-each = this.parser.for-each}
}

define return<a>(x: a): parser(a) {
  Parser(function (xs) {
    Pair(OK(x), xs)
  })
}

define argument-parser<a, b>(mx: parser(a), k: (a) -> parser(b)): parser(b) {
  Parser(function (xs) {
    let Parser of {reader = f} = mx in
    let Pair(mv, ys) = f(xs) in
    match mv {
    | Error(e) =>
      Pair(Error(e), ys)
    | OK(v) =>
      let Parser of {reader = g} = k(v) in
      g(ys)
    }
  })
}

define parse-arguments<a>(mx: parser(a), arguments: list(text)): except(error, a) {
  let Parser of {reader} = mx in
  let Pair(result, rest) = reader(arguments) in
  match result {
  | Error(e) =>
    Error(e)
  | OK(v) =>
    let len on rest = length(rest) in
    if eq-int(len, 0) {
      OK(v)
    } else {
      Error(Remaining-Arguments(rest))
    }
  }
}

define run<a>(mx: parser(a)): except(error, a) {
  let argv = get-argv() in
  let arguments = drop(argv, 1) in
  parse-arguments(mx, arguments)
}
